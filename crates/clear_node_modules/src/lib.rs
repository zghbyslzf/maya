use std::fs;
use std::path::Path;
use std::io;
use wasm_bindgen::prelude::*;
use web_sys::console;



/// 清除目录中的所有 node_modules 文件夹
#[wasm_bindgen]
pub fn clear_node_modules(dir: String) -> Result<usize, JsValue> {
    console::log_1(&format!("收到目录参数: {}", dir).into());
    let mut count = 0;
    
    // 遍历目录
    clear_node_modules_in_dir(Path::new(&dir), &mut count).map_err(|e| JsValue::from_str(&e.to_string()))?;
    
    Ok(count)
}

fn clear_node_modules_in_dir(dir: &Path, count: &mut usize) -> io::Result<()> {
    console::log_1(&format!("处理路径: {}", dir.display()).into());
    if !dir.is_dir() {
        return Ok(());
    }
    
    // 检查当前目录是否为 node_modules
    if dir.file_name().map_or(false, |name| name == "node_modules") {
        fs::remove_dir_all(dir)?;
        *count += 1;
        console::log_1(&format!("已删除: {}", dir.display()).into());
        return Ok(());
    }
    
    // 保存需要递归处理的目录
    let mut subdirs = Vec::new();
    
    // 检查当前目录中的 node_modules
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            if path.file_name().map_or(false, |name| name == "node_modules") {
                fs::remove_dir_all(&path)?;
                *count += 1;
                console::log_1(&format!("发现子目录: {}", path.display()).into());
            } else {
                // 将子目录保存起来，稍后处理
                subdirs.push(path);
            }
        }
    }
    
    // 递归处理子目录
    for subdir in subdirs {
        clear_node_modules_in_dir(&subdir, count)?;
    }
    
    Ok(())
}
