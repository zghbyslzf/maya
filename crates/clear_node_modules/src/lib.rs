use std::fs;
use std::path::Path;
use std::io;

///
/// 
/// 
/// 
// pub fn add(left: usize, right: usize) -> usize {
//     left + right
// }

// #[cfg(test)]
// mod tests {
//     use super::*;

//     #[test]
//     fn it_works() {
//         let result = add(2, 2);
//         assert_eq!(result, 4);
//     }
// }

/// 清除目录中的所有 node_modules 文件夹
pub fn clear_node_modules<P: AsRef<Path>>(dir: P) -> io::Result<usize> {
    let mut count = 0;
    
    // 遍历目录
    clear_node_modules_in_dir(dir.as_ref(), &mut count)?;
    
    Ok(count)
}

fn clear_node_modules_in_dir(dir: &Path, count: &mut usize) -> io::Result<()> {
    if !dir.is_dir() {
        return Ok(());
    }
    
    // 检查当前目录是否为 node_modules
    if dir.file_name().map_or(false, |name| name == "node_modules") {
        fs::remove_dir_all(dir)?;
        *count += 1;
        println!("已删除: {}", dir.display());
        return Ok(());
    }
    
    // 保存需要递归处理的目录
    let mut subdirs = Vec::new();
    
    // 检查当前目录中的 node_modules
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();
        
        if path.is_dir() {
            if path.file_name().map_or(false, |name| name == "node_modules") {
                fs::remove_dir_all(&path)?;
                *count += 1;
                println!("已删除: {}", path.display());
            } else {
                // 将子目录保存起来，稍后处理
                subdirs.push(path);
            }
        }
    }
    
    // 递归处理子目录
    for subdir in subdirs {
        clear_node_modules_in_dir(&subdir, count)?;
    }
    
    Ok(())
}
